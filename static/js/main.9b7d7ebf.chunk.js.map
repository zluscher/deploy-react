{"version":3,"sources":["SVGUtils.js","Icon3D.js","App.js","index.js"],"names":["parseFloats","string","array","split","i","length","number","indexOf","lastIndexOf","s","splice","parseFloatWithUnits","theUnit","String","n","units","u","endsWith","substring","scale","undefined","unitConversion","parseFloat","getReflection","a","b","parseArcCommand","path","rx","ry","x_axis_rotation","large_arc_flag","sweep_flag","start","end","Math","PI","abs","dx2","x","dy2","y","x1p","cos","sin","y1p","rxs","rys","x1ps","y1ps","cr","sqrt","dq","pq","q","max","cxp","cyp","cx","cy","theta","svgAngle","delta","currentPath","absellipse","lineTo","mm","cm","in","pt","pc","px","ux","uy","vx","vy","dot","len","ang","acos","min","Icon3D","color","isCCW","props","SvgPath","d","position","ShapePath","point","Vector2","control","firstPoint","isFirstPoint","doSetFirstPoint","commands","match","l","command","type","charAt","data","substr","trim","j","jl","numbers","moveTo","copy","bezierCurveTo","quadraticCurveTo","clone","autoClose","curves","currentPoint","console","warn","parsePathData","shapes","toShapes","map","shape","args","side","THREE","icons","mdiSpotify","invert","mdiApple","mdiReact","mdiGithub","mdiGit","App","idxMiddle","colorManagement","camera","intensity","OrbitControls","AnimatedIcon","ContactShadows","opacity","width","height","blur","far","useState","spins","setSpins","spring","useSpring","rotation","canSpin","useRef","bind","useGesture","onMove","vxvy","current","sign","onPointerOver","group","Turntable","Float","amplitude","speed","transparent","visible","ref","useFrame","_","clock","elapsedTime","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.9b7d7ebf.chunk.js","sourcesContent":["import { ShapePath, Vector2 } from 'three'\r\n\r\n// Extracted from https://github.com/mrdoob/three.js/blob/master/examples/jsm/loaders/SVGLoader.js\r\n\r\n// Default dots per inch\r\nconst defaultDPI = 90\r\n\r\n// Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\r\nconst defaultUnit = 'px'\r\n\r\nexport function parsePathData(d) {\r\n  var path = new ShapePath()\r\n\r\n  var point = new Vector2()\r\n  var control = new Vector2()\r\n\r\n  var firstPoint = new Vector2()\r\n  var isFirstPoint = true\r\n  var doSetFirstPoint = false\r\n\r\n  var commands = d.match(/[a-df-z][^a-df-z]*/gi)\r\n\r\n  for (var i = 0, l = commands.length; i < l; i++) {\r\n    var command = commands[i]\r\n\r\n    var type = command.charAt(0)\r\n    var data = command.substr(1).trim()\r\n\r\n    if (isFirstPoint === true) {\r\n      doSetFirstPoint = true\r\n      isFirstPoint = false\r\n    }\r\n\r\n    switch (type) {\r\n      case 'M':\r\n        var numbers = parseFloats(data)\r\n        for (var j = 0, jl = numbers.length; j < jl; j += 2) {\r\n          point.x = numbers[j + 0]\r\n          point.y = numbers[j + 1]\r\n          control.x = point.x\r\n          control.y = point.y\r\n\r\n          if (j === 0) {\r\n            path.moveTo(point.x, point.y)\r\n          } else {\r\n            path.lineTo(point.x, point.y)\r\n          }\r\n\r\n          if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\r\n        }\r\n\r\n        break\r\n\r\n      case 'H':\r\n        var numbers = parseFloats(data)\r\n\r\n        for (var j = 0, jl = numbers.length; j < jl; j++) {\r\n          point.x = numbers[j]\r\n          control.x = point.x\r\n          control.y = point.y\r\n          path.lineTo(point.x, point.y)\r\n\r\n          if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\r\n        }\r\n\r\n        break\r\n\r\n      case 'V':\r\n        var numbers = parseFloats(data)\r\n\r\n        for (var j = 0, jl = numbers.length; j < jl; j++) {\r\n          point.y = numbers[j]\r\n          control.x = point.x\r\n          control.y = point.y\r\n          path.lineTo(point.x, point.y)\r\n\r\n          if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\r\n        }\r\n\r\n        break\r\n\r\n      case 'L':\r\n        var numbers = parseFloats(data)\r\n\r\n        for (var j = 0, jl = numbers.length; j < jl; j += 2) {\r\n          point.x = numbers[j + 0]\r\n          point.y = numbers[j + 1]\r\n          control.x = point.x\r\n          control.y = point.y\r\n          path.lineTo(point.x, point.y)\r\n\r\n          if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\r\n        }\r\n\r\n        break\r\n\r\n      case 'C':\r\n        var numbers = parseFloats(data)\r\n\r\n        for (var j = 0, jl = numbers.length; j < jl; j += 6) {\r\n          path.bezierCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], numbers[j + 5])\r\n          control.x = numbers[j + 2]\r\n          control.y = numbers[j + 3]\r\n          point.x = numbers[j + 4]\r\n          point.y = numbers[j + 5]\r\n\r\n          if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\r\n        }\r\n\r\n        break\r\n\r\n      case 'S':\r\n        var numbers = parseFloats(data)\r\n\r\n        for (var j = 0, jl = numbers.length; j < jl; j += 4) {\r\n          path.bezierCurveTo(\r\n            getReflection(point.x, control.x),\r\n            getReflection(point.y, control.y),\r\n            numbers[j + 0],\r\n            numbers[j + 1],\r\n            numbers[j + 2],\r\n            numbers[j + 3]\r\n          )\r\n          control.x = numbers[j + 0]\r\n          control.y = numbers[j + 1]\r\n          point.x = numbers[j + 2]\r\n          point.y = numbers[j + 3]\r\n\r\n          if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\r\n        }\r\n\r\n        break\r\n\r\n      case 'Q':\r\n        var numbers = parseFloats(data)\r\n\r\n        for (var j = 0, jl = numbers.length; j < jl; j += 4) {\r\n          path.quadraticCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3])\r\n          control.x = numbers[j + 0]\r\n          control.y = numbers[j + 1]\r\n          point.x = numbers[j + 2]\r\n          point.y = numbers[j + 3]\r\n\r\n          if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\r\n        }\r\n\r\n        break\r\n\r\n      case 'T':\r\n        var numbers = parseFloats(data)\r\n\r\n        for (var j = 0, jl = numbers.length; j < jl; j += 2) {\r\n          var rx = getReflection(point.x, control.x)\r\n          var ry = getReflection(point.y, control.y)\r\n          path.quadraticCurveTo(rx, ry, numbers[j + 0], numbers[j + 1])\r\n          control.x = rx\r\n          control.y = ry\r\n          point.x = numbers[j + 0]\r\n          point.y = numbers[j + 1]\r\n\r\n          if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\r\n        }\r\n\r\n        break\r\n\r\n      case 'A':\r\n        var numbers = parseFloats(data)\r\n\r\n        for (var j = 0, jl = numbers.length; j < jl; j += 7) {\r\n          // skip command if start point == end point\r\n          if (numbers[j + 5] == point.x && numbers[j + 6] == point.y) continue\r\n\r\n          var start = point.clone()\r\n          point.x = numbers[j + 5]\r\n          point.y = numbers[j + 6]\r\n          control.x = point.x\r\n          control.y = point.y\r\n          parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point)\r\n\r\n          if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\r\n        }\r\n\r\n        break\r\n\r\n      case 'm':\r\n        var numbers = parseFloats(data)\r\n\r\n        for (var j = 0, jl = numbers.length; j < jl; j += 2) {\r\n          point.x += numbers[j + 0]\r\n          point.y += numbers[j + 1]\r\n          control.x = point.x\r\n          control.y = point.y\r\n\r\n          if (j === 0) {\r\n            path.moveTo(point.x, point.y)\r\n          } else {\r\n            path.lineTo(point.x, point.y)\r\n          }\r\n\r\n          if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\r\n        }\r\n\r\n        break\r\n\r\n      case 'h':\r\n        var numbers = parseFloats(data)\r\n\r\n        for (var j = 0, jl = numbers.length; j < jl; j++) {\r\n          point.x += numbers[j]\r\n          control.x = point.x\r\n          control.y = point.y\r\n          path.lineTo(point.x, point.y)\r\n\r\n          if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\r\n        }\r\n\r\n        break\r\n\r\n      case 'v':\r\n        var numbers = parseFloats(data)\r\n\r\n        for (var j = 0, jl = numbers.length; j < jl; j++) {\r\n          point.y += numbers[j]\r\n          control.x = point.x\r\n          control.y = point.y\r\n          path.lineTo(point.x, point.y)\r\n\r\n          if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\r\n        }\r\n\r\n        break\r\n\r\n      case 'l':\r\n        var numbers = parseFloats(data)\r\n\r\n        for (var j = 0, jl = numbers.length; j < jl; j += 2) {\r\n          point.x += numbers[j + 0]\r\n          point.y += numbers[j + 1]\r\n          control.x = point.x\r\n          control.y = point.y\r\n          path.lineTo(point.x, point.y)\r\n\r\n          if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\r\n        }\r\n\r\n        break\r\n\r\n      case 'c':\r\n        var numbers = parseFloats(data)\r\n\r\n        for (var j = 0, jl = numbers.length; j < jl; j += 6) {\r\n          path.bezierCurveTo(\r\n            point.x + numbers[j + 0],\r\n            point.y + numbers[j + 1],\r\n            point.x + numbers[j + 2],\r\n            point.y + numbers[j + 3],\r\n            point.x + numbers[j + 4],\r\n            point.y + numbers[j + 5]\r\n          )\r\n          control.x = point.x + numbers[j + 2]\r\n          control.y = point.y + numbers[j + 3]\r\n          point.x += numbers[j + 4]\r\n          point.y += numbers[j + 5]\r\n\r\n          if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\r\n        }\r\n\r\n        break\r\n\r\n      case 's':\r\n        var numbers = parseFloats(data)\r\n\r\n        for (var j = 0, jl = numbers.length; j < jl; j += 4) {\r\n          path.bezierCurveTo(\r\n            getReflection(point.x, control.x),\r\n            getReflection(point.y, control.y),\r\n            point.x + numbers[j + 0],\r\n            point.y + numbers[j + 1],\r\n            point.x + numbers[j + 2],\r\n            point.y + numbers[j + 3]\r\n          )\r\n          control.x = point.x + numbers[j + 0]\r\n          control.y = point.y + numbers[j + 1]\r\n          point.x += numbers[j + 2]\r\n          point.y += numbers[j + 3]\r\n\r\n          if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\r\n        }\r\n\r\n        break\r\n\r\n      case 'q':\r\n        var numbers = parseFloats(data)\r\n\r\n        for (var j = 0, jl = numbers.length; j < jl; j += 4) {\r\n          path.quadraticCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3])\r\n          control.x = point.x + numbers[j + 0]\r\n          control.y = point.y + numbers[j + 1]\r\n          point.x += numbers[j + 2]\r\n          point.y += numbers[j + 3]\r\n\r\n          if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\r\n        }\r\n\r\n        break\r\n\r\n      case 't':\r\n        var numbers = parseFloats(data)\r\n\r\n        for (var j = 0, jl = numbers.length; j < jl; j += 2) {\r\n          var rx = getReflection(point.x, control.x)\r\n          var ry = getReflection(point.y, control.y)\r\n          path.quadraticCurveTo(rx, ry, point.x + numbers[j + 0], point.y + numbers[j + 1])\r\n          control.x = rx\r\n          control.y = ry\r\n          point.x = point.x + numbers[j + 0]\r\n          point.y = point.y + numbers[j + 1]\r\n\r\n          if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\r\n        }\r\n\r\n        break\r\n\r\n      case 'a':\r\n        var numbers = parseFloats(data)\r\n\r\n        for (var j = 0, jl = numbers.length; j < jl; j += 7) {\r\n          // skip command if no displacement\r\n          if (numbers[j + 5] == 0 && numbers[j + 6] == 0) continue\r\n\r\n          var start = point.clone()\r\n          point.x += numbers[j + 5]\r\n          point.y += numbers[j + 6]\r\n          control.x = point.x\r\n          control.y = point.y\r\n          parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point)\r\n\r\n          if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\r\n        }\r\n\r\n        break\r\n\r\n      case 'Z':\r\n      case 'z':\r\n        path.currentPath.autoClose = true\r\n\r\n        if (path.currentPath.curves.length > 0) {\r\n          // Reset point to beginning of Path\r\n          point.copy(firstPoint)\r\n          path.currentPath.currentPoint.copy(point)\r\n          isFirstPoint = true\r\n        }\r\n\r\n        break\r\n\r\n      default:\r\n        console.warn(command)\r\n    }\r\n    doSetFirstPoint = false\r\n  }\r\n\r\n  return path\r\n}\r\n\r\nfunction parseFloats(string) {\r\n  var array = string.split(/[\\s,]+|(?=\\s?[+\\-])/)\r\n\r\n  for (var i = 0; i < array.length; i++) {\r\n    var number = array[i]\r\n    // Handle values like 48.6037.7.8\r\n    // TODO Find a regex for this\r\n\r\n    if (number.indexOf('.') !== number.lastIndexOf('.')) {\r\n      var split = number.split('.')\r\n\r\n      for (var s = 2; s < split.length; s++) {\r\n        array.splice(i + s - 1, 0, '0.' + split[s])\r\n      }\r\n    }\r\n\r\n    array[i] = parseFloatWithUnits(number)\r\n  }\r\n\r\n  return array\r\n}\r\n\r\nfunction parseFloatWithUnits(string) {\r\n  var theUnit = 'px'\r\n\r\n  if (typeof string === 'string' || string instanceof String) {\r\n    for (var i = 0, n = units.length; i < n; i++) {\r\n      var u = units[i]\r\n\r\n      if (string.endsWith(u)) {\r\n        theUnit = u\r\n        string = string.substring(0, string.length - u.length)\r\n        break\r\n      }\r\n    }\r\n  }\r\n\r\n  var scale = undefined\r\n\r\n  if (theUnit === 'px' && defaultUnit !== 'px') {\r\n    // Conversion scale from  pixels to inches, then to default units\r\n\r\n    scale = unitConversion['in'][defaultUnit] / defaultDPI\r\n  } else {\r\n    scale = unitConversion[theUnit][defaultUnit]\r\n\r\n    if (scale < 0) {\r\n      // Conversion scale to pixels\r\n\r\n      scale = unitConversion[theUnit]['in'] * defaultDPI\r\n    }\r\n  }\r\n\r\n  return scale * parseFloat(string)\r\n}\r\n\r\nfunction getReflection(a, b) {\r\n  return a - (b - a)\r\n}\r\n\r\nfunction parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\r\n  if (rx == 0 || ry == 0) {\r\n    // draw a line if either of the radii == 0\r\n    path.lineTo(end.x, end.y)\r\n    return\r\n  }\r\n\r\n  x_axis_rotation = (x_axis_rotation * Math.PI) / 180\r\n\r\n  // Ensure radii are positive\r\n  rx = Math.abs(rx)\r\n  ry = Math.abs(ry)\r\n\r\n  // Compute (x1', y1')\r\n  var dx2 = (start.x - end.x) / 2.0\r\n  var dy2 = (start.y - end.y) / 2.0\r\n  var x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2\r\n  var y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2\r\n\r\n  // Compute (cx', cy')\r\n  var rxs = rx * rx\r\n  var rys = ry * ry\r\n  var x1ps = x1p * x1p\r\n  var y1ps = y1p * y1p\r\n\r\n  // Ensure radii are large enough\r\n  var cr = x1ps / rxs + y1ps / rys\r\n\r\n  if (cr > 1) {\r\n    // scale up rx,ry equally so cr == 1\r\n    var s = Math.sqrt(cr)\r\n    rx = s * rx\r\n    ry = s * ry\r\n    rxs = rx * rx\r\n    rys = ry * ry\r\n  }\r\n\r\n  var dq = rxs * y1ps + rys * x1ps\r\n  var pq = (rxs * rys - dq) / dq\r\n  var q = Math.sqrt(Math.max(0, pq))\r\n  if (large_arc_flag === sweep_flag) q = -q\r\n  var cxp = (q * rx * y1p) / ry\r\n  var cyp = (-q * ry * x1p) / rx\r\n\r\n  // Step 3: Compute (cx, cy) from (cx', cy')\r\n  var cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2\r\n  var cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2\r\n\r\n  // Step 4: Compute θ1 and Δθ\r\n  var theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry)\r\n  var delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2)\r\n\r\n  path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation)\r\n}\r\n\r\n// Units\r\n\r\nvar units = ['mm', 'cm', 'in', 'pt', 'pc', 'px']\r\n\r\n// Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\r\nvar unitConversion = {\r\n  mm: {\r\n    mm: 1,\r\n    cm: 0.1,\r\n    in: 1 / 25.4,\r\n    pt: 72 / 25.4,\r\n    pc: 6 / 25.4,\r\n    px: -1,\r\n  },\r\n  cm: {\r\n    mm: 10,\r\n    cm: 1,\r\n    in: 1 / 2.54,\r\n    pt: 72 / 2.54,\r\n    pc: 6 / 2.54,\r\n    px: -1,\r\n  },\r\n  in: {\r\n    mm: 25.4,\r\n    cm: 2.54,\r\n    in: 1,\r\n    pt: 72,\r\n    pc: 6,\r\n    px: -1,\r\n  },\r\n  pt: {\r\n    mm: 25.4 / 72,\r\n    cm: 2.54 / 72,\r\n    in: 1 / 72,\r\n    pt: 1,\r\n    pc: 6 / 72,\r\n    px: -1,\r\n  },\r\n  pc: {\r\n    mm: 25.4 / 6,\r\n    cm: 2.54 / 6,\r\n    in: 1 / 6,\r\n    pt: 72 / 6,\r\n    pc: 1,\r\n    px: -1,\r\n  },\r\n  px: {\r\n    px: 1,\r\n  },\r\n}\r\n\r\nfunction svgAngle(ux, uy, vx, vy) {\r\n  var dot = ux * vx + uy * vy\r\n  var len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy)\r\n  var ang = Math.acos(Math.max(-1, Math.min(1, dot / len))) // floating point precision, slightly over values appear\r\n  if (ux * vy - uy * vx < 0) ang = -ang\r\n  return ang\r\n}\r\n","import { parsePathData } from './SVGUtils'\r\nimport * as THREE from 'three'\r\n\r\nexport default function Icon3D({ path, color, isCCW, ...props }) {\r\n  // Size and position normalization\r\n  return (\r\n    <group {...props}>\r\n      <SvgPath d={path} color={color} isCCW={isCCW} scale={[1 / 12, -1 / 12, 1 / 12]} position={[-1, 1, 0]} />\r\n    </group>\r\n  )\r\n}\r\n\r\nfunction SvgPath({ d, color = '#000', isCCW = true, ...props }) {\r\n  const path = parsePathData(d)\r\n  const shapes = path.toShapes(isCCW)\r\n  return (\r\n    <group {...props}>\r\n      {shapes.map((shape, i) => (\r\n        <mesh key={i}>\r\n          <shapeBufferGeometry args={[shape]} />\r\n          <meshBasicMaterial color={color} side={THREE.DoubleSide} />\r\n        </mesh>\r\n      ))}\r\n    </group>\r\n  )\r\n}\r\n","import { useRef, useState } from 'react'\r\nimport { Canvas, useFrame } from 'react-three-fiber'\r\nimport { OrbitControls, ContactShadows, Sphere } from '@react-three/drei'\r\nimport { a, useSpring } from '@react-spring/three'\r\nimport { useGesture } from 'react-use-gesture'\r\n\r\nimport { mdiReact, mdiGithub, mdiSpotify, mdiApple, mdiGit } from '@mdi/js'\r\nimport Icon3D from './Icon3D'\r\n\r\n// You can use any icon from @mdi/js:\r\nconst icons = [\r\n  { path: mdiSpotify, color: '#1ed760', invert: true },\r\n  { path: mdiApple, color: '#ddd' },\r\n  { path: mdiReact, color: '#61dafb' },\r\n  { path: mdiGithub, color: '#000' },\r\n  { path: mdiGit, color: '#f05030' },\r\n]\r\n\r\nexport default function App() {\r\n  // For centering list of icons\r\n  const idxMiddle = (icons.length - 1) / 2\r\n  return (\r\n    <Canvas colorManagement={false} camera={{ position: [0, 1, 10] }}>\r\n      <ambientLight intensity={[0.2]} />\r\n      <pointLight position={[2, 2, 2]} />\r\n      <OrbitControls />\r\n      {icons.map((props, i) => (\r\n        <AnimatedIcon key={i} {...props} position-x={(i - idxMiddle) * 2} />\r\n      ))}\r\n      <ContactShadows rotation-x={Math.PI / 2} position={[0, -1.5, 0]} opacity={0.4} width={10} height={10} blur={2} far={1.5} />\r\n    </Canvas>\r\n  )\r\n}\r\n\r\nfunction AnimatedIcon({ path, color, invert = false, ...props }) {\r\n  const [spins, setSpins] = useState(0)\r\n  const spring = useSpring({ rotation: [0, spins * Math.PI, 0] })\r\n  const canSpin = useRef(false)\r\n  const bind = useGesture({\r\n    onMove: ({ vxvy: [vx] }) => {\r\n      if (canSpin.current && vx !== 0) {\r\n        setSpins(spins + Math.sign(vx))\r\n        canSpin.current = false\r\n      }\r\n    },\r\n    onPointerOver: () => (canSpin.current = true),\r\n  })\r\n  return (\r\n    <a.group {...spring} {...bind()} {...props}>\r\n      <Turntable>\r\n        <Float amplitude={0.3} speed={2}>\r\n          <Icon3D path={path} color={color} isCCW={!invert} />\r\n          {/* Transparent sphere to generate a shadow */}\r\n          <Sphere args={[1, 4, 32]} scale-z={0.1}>\r\n            <meshStandardMaterial opacity={0} transparent />\r\n          </Sphere>\r\n          {/* Bounding sphere for events */}\r\n          <Sphere visible={false} />\r\n        </Float>\r\n      </Turntable>\r\n    </a.group>\r\n  )\r\n}\r\n\r\n// Slowly spin around\r\nfunction Turntable(props) {\r\n  const ref = useRef()\r\n  useFrame((_, delta) => (ref.current.rotation.y += delta))\r\n  return <group ref={ref} {...props} />\r\n}\r\n\r\n// Float up and down\r\nfunction Float({ speed = 1, amplitude = 1, ...props }) {\r\n  const ref = useRef()\r\n  useFrame(({ clock }) => (ref.current.position.y = amplitude * Math.sin(clock.elapsedTime * speed)))\r\n  return <group ref={ref} {...props} />\r\n}\r\n","import React from 'react'\r\nimport ReactDOM from 'react-dom'\r\nimport './styles.css'\r\nimport App from './App'\r\n\r\nReactDOM.render(<App />, document.getElementById('root'))\r\n"],"sourceRoot":""}